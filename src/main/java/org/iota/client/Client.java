// Automatically generated by flapigen
package org.iota.client;


public final class Client {

    private Client() {}

    public static ClientBuilder Builder() {
        long ret = do_Builder();
        ClientBuilder convRet = new ClientBuilder(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_Builder();
    /**
     * GET /health endpoint
     */
    public final boolean getHealth() {
        boolean ret = do_getHealth(mNativeObj);

        return ret;
    }
    private static native boolean do_getHealth(long self);
    /**
     * GET /health endpoint for the passed node
     */
    public final boolean getNodeHealth(String node) {
        boolean ret = do_getNodeHealth(mNativeObj, node);

        return ret;
    }
    private static native boolean do_getNodeHealth(long self, String node);
    /**
     * GET /api/v1/info endpoint
     */
    public final NodeInfoWrapper getInfo() {
        long ret = do_getInfo(mNativeObj);
        NodeInfoWrapper convRet = new NodeInfoWrapper(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_getInfo(long self);
    /**
     * GET /api/v1/peers endpoint
     */
    public final PeerDto [] getPeers() {
        PeerDto [] ret = do_getPeers(mNativeObj);

        return ret;
    }
    private static native PeerDto [] do_getPeers(long self);
    /**
     * GET /api/v1/tips endpoint
     */
    public final java.lang.String [] getTips() {
        java.lang.String [] ret = do_getTips(mNativeObj);

        return ret;
    }
    private static native java.lang.String [] do_getTips(long self);
    /**
     * GET /api/v1/outputs/{outputId} endpoint
     * Find an output by its transaction_id and corresponding output_index.
     */
    public final OutputResponse getOutput(String output_id) {
        long ret = do_getOutput(mNativeObj, output_id);
        OutputResponse convRet = new OutputResponse(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_getOutput(long self, String output_id);
    /**
     * GET /api/v1/addresses/{address} endpoint
     */
    public final GetAddressBuilder getAddress() {
        long ret = do_getAddress(mNativeObj);
        GetAddressBuilder convRet = new GetAddressBuilder(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_getAddress(long self);
    /**
     * Return the balance in iota for the given address; No seed or security level needed to do this
     * since we are only checking and already know the address.
     */
    public final BalanceAddressResponse getAddressBalance(String address) {
        long ret = do_getAddressBalance(mNativeObj, address);
        BalanceAddressResponse convRet = new BalanceAddressResponse(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_getAddressBalance(long self, String address);
    /**
     * Return the balance in iota for the given addresses; No seed or security level needed to do this
     * since we are only checking and already know the addresses.
     */
    public final BalanceAddressResponse [] getAddressesBalances(java.lang.String [] addresses) {
        BalanceAddressResponse [] ret = do_getAddressesBalances(mNativeObj, addresses);

        return ret;
    }
    private static native BalanceAddressResponse [] do_getAddressesBalances(long self, java.lang.String [] addresses);
    /**
     * Find all outputs based on the requests criteria. This method will try to query multiple nodes if
     * the request amount exceeds individual node limit.
     */
    public final OutputResponse [] findOutputs(java.lang.String [] output_ids, java.lang.String [] addresses) {
        OutputResponse [] ret = do_findOutputs(mNativeObj, output_ids, addresses);

        return ret;
    }
    private static native OutputResponse [] do_findOutputs(long self, java.lang.String [] output_ids, java.lang.String [] addresses);
    /**
     * GET /api/v1/milestones/{index} endpoint
     * Get the milestone by the given index.
     */
    public final MilestoneResponse getMilestone(long index) {
        long ret = do_getMilestone(mNativeObj, index);
        MilestoneResponse convRet = new MilestoneResponse(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_getMilestone(long self, long index);
    /**
     * GET /api/v1/milestones/{index}/utxo-changes endpoint
     * Gets the utxo changes by the given milestone index.
     */
    public final MilestoneUtxoChangesResponse getMilestoneUtxoChanges(long index) {
        long ret = do_getMilestoneUtxoChanges(mNativeObj, index);
        MilestoneUtxoChangesResponse convRet = new MilestoneUtxoChangesResponse(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_getMilestoneUtxoChanges(long self, long index);
    /**
     * GET /api/v1/receipts endpoint
     * Get all receipts.
     */
    public final ReceiptDto [] getReceipts() {
        ReceiptDto [] ret = do_getReceipts(mNativeObj);

        return ret;
    }
    private static native ReceiptDto [] do_getReceipts(long self);
    /**
     * GET /api/v1/receipts/{migratedAt} endpoint
     * Get the receipts by the given milestone index.
     */
    public final ReceiptDto [] getReceiptsMigratedAt(long index) {
        ReceiptDto [] ret = do_getReceiptsMigratedAt(mNativeObj, index);

        return ret;
    }
    private static native ReceiptDto [] do_getReceiptsMigratedAt(long self, long index);
    /**
     * GET /api/v1/treasury endpoint
     * Get the treasury output.
     */
    public final TreasuryResponse getTreasury() {
        long ret = do_getTreasury(mNativeObj);
        TreasuryResponse convRet = new TreasuryResponse(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_getTreasury(long self);
    /**
     * GET /api/v1/transactions/{transactionId}/included-message
     * Returns the included message of the transaction.
     */
    public final Message getIncludedMessage(TransactionId transaction_id) {
        long a0 = transaction_id.mNativeObj;
        transaction_id.mNativeObj = 0;

        long ret = do_getIncludedMessage(mNativeObj, a0);
        Message convRet = new Message(InternalPointerMarker.RAW_PTR, ret);

        JNIReachabilityFence.reachabilityFence1(transaction_id);

        return convRet;
    }
    private static native long do_getIncludedMessage(long self, long transaction_id);
    /**
     * POST /api/v1/messages endpoint
     */
    public final MessageId postMessage(Message msg) {
        long a0 = msg.mNativeObj;
        msg.mNativeObj = 0;

        long ret = do_postMessage(mNativeObj, a0);
        MessageId convRet = new MessageId(InternalPointerMarker.RAW_PTR, ret);

        JNIReachabilityFence.reachabilityFence1(msg);

        return convRet;
    }
    private static native long do_postMessage(long self, long msg);
    /**
     * Reattaches messages for provided message id. Messages can be reattached only if they are valid and haven't been
     * confirmed for a while.
     */
    public final MessageWrap reattach(MessageId message_id) {
        long a0 = message_id.mNativeObj;
        message_id.mNativeObj = 0;

        long ret = do_reattach(mNativeObj, a0);
        MessageWrap convRet = new MessageWrap(InternalPointerMarker.RAW_PTR, ret);

        JNIReachabilityFence.reachabilityFence1(message_id);

        return convRet;
    }
    private static native long do_reattach(long self, long message_id);
    /**
     * Reattach a message without checking if it should be reattached
     */
    public final MessageWrap reattachUnchecked(MessageId message_id) {
        long a0 = message_id.mNativeObj;
        message_id.mNativeObj = 0;

        long ret = do_reattachUnchecked(mNativeObj, a0);
        MessageWrap convRet = new MessageWrap(InternalPointerMarker.RAW_PTR, ret);

        JNIReachabilityFence.reachabilityFence1(message_id);

        return convRet;
    }
    private static native long do_reattachUnchecked(long self, long message_id);
    /**
     * Promotes a message. The method should validate if a promotion is necessary through get_message. If not, the
     * method should error out and should not allow unnecessary promotions.
     */
    public final MessageWrap promote(MessageId message_id) {
        long a0 = message_id.mNativeObj;
        message_id.mNativeObj = 0;

        long ret = do_promote(mNativeObj, a0);
        MessageWrap convRet = new MessageWrap(InternalPointerMarker.RAW_PTR, ret);

        JNIReachabilityFence.reachabilityFence1(message_id);

        return convRet;
    }
    private static native long do_promote(long self, long message_id);
    /**
     * Promote a message without checking if it should be promoted
     */
    public final MessageWrap promoteUnchecked(MessageId message_id) {
        long a0 = message_id.mNativeObj;
        message_id.mNativeObj = 0;

        long ret = do_promoteUnchecked(mNativeObj, a0);
        MessageWrap convRet = new MessageWrap(InternalPointerMarker.RAW_PTR, ret);

        JNIReachabilityFence.reachabilityFence1(message_id);

        return convRet;
    }
    private static native long do_promoteUnchecked(long self, long message_id);
    /**
     * Return the balance for a provided seed and its wallet chain account index.
     * Addresses with balance must be consecutive, so this method will return once it encounters a zero
     * balance address.
     */
    public final GetBalanceBuilderApi getBalance(String seed) {
        long ret = do_getBalance(mNativeObj, seed);
        GetBalanceBuilderApi convRet = new GetBalanceBuilderApi(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_getBalance(long self, String seed);
    /**
     * A generic send function for easily sending transaction or indexation messages.
     */
    public final ClientMessageBuilder message() {
        long ret = do_message(mNativeObj);
        ClientMessageBuilder convRet = new ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_message(long self);
    /**
     * GET /api/v1/messages/{messageId} endpoint
     */
    public final GetMessageBuilder getMessage() {
        long ret = do_getMessage(mNativeObj);
        GetMessageBuilder convRet = new GetMessageBuilder(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_getMessage(long self);
    /**
     * Return a list of addresses from the seed regardless of their validity.
     */
    public final GetAddressesBuilder getAddresses(String seed) {
        long ret = do_getAddresses(mNativeObj, seed);
        GetAddressesBuilder convRet = new GetAddressesBuilder(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_getAddresses(long self, String seed);
    /**
     * Retries (promotes or reattaches) a message for provided message id until it's included (referenced by a
     * milestone). Default interval is 5 seconds and max attempts is 10. Returns reattached messages. Set to -1 for defaults.
     */
    public final MessageWrap [] retryUntilIncluded(MessageId message_id, long interval, long max_attempts) {
        long a0 = message_id.mNativeObj;
        message_id.mNativeObj = 0;

        MessageWrap [] ret = do_retryUntilIncluded(mNativeObj, a0, interval, max_attempts);

        JNIReachabilityFence.reachabilityFence1(message_id);

        return ret;
    }
    private static native MessageWrap [] do_retryUntilIncluded(long self, long message_id, long interval, long max_attempts);
    /**
     * Returns a handle to the MQTT topics manager.
     */
    public final MqttManager subscriber() {
        long ret = do_subscriber(mNativeObj);
        MqttManager convRet = new MqttManager(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_subscriber(long self);
    /**
     * Generates a new mnemonic.
     */
    public static native String generateMnemonic();
    /**
     * Returns a hex encoded seed for a mnemonic.
     */
    public static native String mnemonicToHexSeed(String mnemonic);
    /**
     * Function to find inputs from addresses for a provided amount (useful for offline signing)
     */
    public final UtxoInput [] findInputs(java.lang.String [] addresses, long amount) {
        UtxoInput [] ret = do_findInputs(mNativeObj, addresses, amount);

        return ret;
    }
    private static native UtxoInput [] do_findInputs(long self, java.lang.String [] addresses, long amount);
    /**
     * Transforms bech32 to hex
     */
    public static native String bech32ToHex(String bech32);
    /**
     * Transforms hex to bech32
     */
    public final String hexToBech32(String hex, String bech32_hrp) {
        String ret = do_hexToBech32(mNativeObj, hex, bech32_hrp);

        return ret;
    }
    private static native String do_hexToBech32(long self, String hex, String bech32_hrp);
    /**
     * Checks if a String address is valid.
     */
    public static native boolean isAddressValid(String address);
    /**
     * Returns a valid Address parsed from a String.
     */
    public static Address parseBech32Address(String address) {
        long ret = do_parseBech32Address(address);
        Address convRet = new Address(InternalPointerMarker.RAW_PTR, ret);

        return convRet;
    }
    private static native long do_parseBech32Address(String address);

    public synchronized void delete() {
        if (mNativeObj != 0) {
            do_delete(mNativeObj);
            mNativeObj = 0;
       }
    }
    @Override
    protected void finalize() throws Throwable {
        try {
            delete();
        }
        finally {
             super.finalize();
        }
    }
    private static native void do_delete(long me);
    /*package*/ Client(InternalPointerMarker marker, long ptr) {
        assert marker == InternalPointerMarker.RAW_PTR;
        this.mNativeObj = ptr;
    }
    /*package*/ long mNativeObj;
}